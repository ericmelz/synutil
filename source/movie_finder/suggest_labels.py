"""
Suggest IMDB labels for unlabeled folders.
Uses movie data pre-generated by OMDB.
Does soft-matching of folder names to titles in the db.
See https://chatgpt.com/share/6828d6bb-ca20-8001-8870-749624e17929
"""
import os
import re
import json
import argparse
import difflib
import openai
import readline
from typing import List, Dict, Optional
from dotenv import load_dotenv
from openai import OpenAI
from pydantic_settings import BaseSettings

IMDB_TAG_RE = re.compile(r'\s*\{imdb-[^\}]+\}$', re.IGNORECASE)
MINE_NEEDS_IMDB = '/Users/ericmelz/Data/code/synutil/source/movie_finder/data/mine_needs_imdb.jsonl'


class Settings(BaseSettings):
    openai_api_key: str = ""
    omdb_api_key: str = ""

    class Config:
        env_file = ".env"


def load_movies(jsonl_path: str) -> List[Dict]:
    movies = []
    with open(jsonl_path, encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                movies.append(json.loads(line))
            except json.decoder.JSONDecodeError:
                print(f"Warning: skipping invalid JSON: {line}")
    return movies


def find_best_match(name: str, movies: List[Dict], cutoff=0.6) -> Optional[Dict]:
    """
    Try exact case-insensitive match on Title, then fuzzy match via difflib.
    """
    lname = name.lower()
    # exact
    for m in movies:
        if m.get("Title", "").lower() == lname:
            return m
    # fuzzy: get top close matches
    titles = [m["Title"] for m in movies]
    matches = difflib.get_close_matches(lname, titles, n=1, cutoff=cutoff)
    if matches:
        title = matches[0]
        for m in movies:
            if m["Title"] == title:
                return m
    return None


def llm_match(name: str, movies: List[Dict]) -> Optional[Dict]:
    """
    Use GPT to pick the correct Title and IMDB ID.
    """
    key = Settings().openai_api_key
    if not key:
        return None

    # build a short prompt with the top few candidates
    titles = [m["Title"] for m in movies]
    # pick 10 closest strings
    candidates = difflib.get_close_matches(name, titles, n=10, cutoff=0.0)
    prompt = (
        f"I have a movie folder named \"{name}\".  Here are some possible titles:\n\n"
        + "\n".join(f"- {t} (IMDB ID: {next(m['imdbID'] for m in movies if m['Title']==t)})"
                    for t in candidates[:10])
    )
    # print(prompt)
    client = OpenAI(api_key=key)
    resp = client.responses.create(
        model="gpt-4o",
        instructions="You are a helpful assistant capable of choosing movie titles",
        input=prompt,
        temperature=0,
    )
    text = resp.output_text
    # print(f'{text=}')
    # extract tt\d+
    m = re.search(r'(tt\d+)', text)
    if not m:
        return None
    imdb_id = m.group(1)
    # find movie dict
    for m in movies:
        if m.get("imdbID", "") == imdb_id:
            return m
    return None


def main():
    settings = Settings()
    movies = load_movies(MINE_NEEDS_IMDB)

    print("BEST MATCH")
    movie = find_best_match("one hundred twenty seven hours", movies)
    if movie:
        print(json.dumps(movie, indent=2))
    else:
        print("No matches found")

    print("\n\nLLM MATCH")
    movie = llm_match("one hundred twenty seven hours", movies)
    if movie:
        print(json.dumps(movie, indent=2))
    else:
        print("No matches found")


if __name__ == '__main__':
    main()
