"""
Suggest IMDB labels for unlabeled folders.
Uses movie data pre-generated by OMDB.
Does soft-matching of folder names to titles in the db.
See https://chatgpt.com/share/6828d6bb-ca20-8001-8870-749624e17929
"""
import difflib
import json
import re
from typing import List, Dict, Optional

from openai import OpenAI
from pydantic_settings import BaseSettings

IMDB_TAG_RE = re.compile(r'\s*\{imdb-[^\}]+\}$', re.IGNORECASE)
MINE_NEEDS_IMDB = '/Users/ericmelz/Data/code/synutil/source/movie_finder/data/mine_needs_imdb.jsonl'
MOVIES_FOLDER = '/Volumes/video-1/movies'


class Settings(BaseSettings):
    openai_api_key: str = ""
    omdb_api_key: str = ""

    class Config:
        env_file = ".env"


def load_movies(jsonl_path: str) -> List[Dict]:
    movies = []
    with open(jsonl_path, encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                movies.append(json.loads(line))
            except json.decoder.JSONDecodeError:
                print(f"Warning: skipping invalid JSON: {line}")
    return movies


def find_best_match(name: str, movies: List[Dict], cutoff=0.6) -> Optional[Dict]:
    """
    Try exact case-insensitive match on Title, then fuzzy match via difflib.
    """
    lname = name.lower()
    # exact
    for m in movies:
        if m.get("Title", "").lower() == lname:
            return m
    # fuzzy: get top close matches
    titles = [m["Title"] for m in movies]
    matches = difflib.get_close_matches(lname, titles, n=1, cutoff=cutoff)
    if matches:
        title = matches[0]
        for m in movies:
            if m["Title"] == title:
                return m
    return None


def llm_match(name: str, movies: List[Dict]) -> Optional[Dict]:
    """
    Use GPT to pick the correct Title and IMDB ID.
    """
    key = Settings().openai_api_key
    if not key:
        return None

    # build a short prompt with the top few candidates
    titles = [m["Title"] for m in movies]
    # pick 10 closest strings
    candidates = difflib.get_close_matches(name, titles, n=10, cutoff=0.0)
    prompt = (
            f"I have a movie folder named \"{name}\".  Here are some possible titles:\n\n"
            + "\n".join(f"- {t} (IMDB ID: {next(m['imdbID'] for m in movies if m['Title'] == t)})"
                        for t in candidates[:10])
    )
    # print(prompt)
    client = OpenAI(api_key=key)
    resp = client.responses.create(
        model="gpt-4o",
        instructions="You are a helpful assistant capable of choosing movie titles",
        input=prompt,
        temperature=0,
    )
    text = resp.output_text
    # print(f'{text=}')
    # extract tt\d+
    m = re.search(r'(tt\d+)', text)
    if not m:
        return None
    imdb_id = m.group(1)
    # find movie dict
    for m in movies:
        if m.get("imdbID", "") == imdb_id:
            return m
    return None


def suggest_new_name(folder: str, movie: Dict) -> str:
    return f"{folder} {{imdb-{movie['imdbID']}}}"


import sys
import tty
import termios
import os


def getch() -> str:
    """
    Read a single character from stdin without waiting for Enter.
    Cross-platform: uses msvcrt on Windows, termios+tty on Unix.
    """
    # Windows
    if os.name == 'nt':
        import msvcrt
        ch = msvcrt.getch()
        # msvcrt returns bytes; decode and normalize
        return ch.decode('utf-8', errors='ignore')
    # Unix
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def prompt_accept(default_name: str) -> Optional[str]:
    """
    Prompt with single-keystroke: y=accept, n=custom, q=quit.
    """
    print(f"Rename to \"{default_name}\"?  (y=yes, n=custom, q=quit) ", end='', flush=True)
    while True:
        ch = getch().lower()
        # echo it so user sees what they typed:
        sys.stdout.write(ch + "\n")
        if ch == 'y':
            return default_name
        elif ch == 'n':
            new_name = input("Enter new folder name (or leave blank to skip): ").strip()
            return new_name or None
        elif ch == 'q':
            print("Quitting.")
            sys.exit(0)
        else:
            print("  [press y, n, or q] ", end='', flush=True)


def main():
    movies = load_movies(MINE_NEEDS_IMDB)
    for entry in sorted(os.listdir(MOVIES_FOLDER)):
        full_path = os.path.join(MOVIES_FOLDER, entry)
        if not os.path.isdir(full_path):
            continue
        if IMDB_TAG_RE.search(full_path):
            continue  # already tagged

        movie = find_best_match(entry, movies)
        if not movie:
            movie = llm_match(entry, movies)

        if not movie:
            print(f"No match for '{entry}'.  Skipping.")
            continue

        suggestion = suggest_new_name(entry, movie)
        chosen = prompt_accept(suggestion)
        if not chosen:
            print(f"Skipping '{entry}'.")
            continue

        new_path = os.path.join(MOVIES_FOLDER, chosen)
        if os.path.exists(new_path):
            print(f"Cannot rename: target {new_path!r} already exists.")
        os.rename(full_path, new_path)
        print(f"Successfully renamed {entry!r} â†’ {chosen!r}.")


if __name__ == '__main__':
    main()
