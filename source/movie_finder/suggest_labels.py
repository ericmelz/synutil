"""
Suggest IMDB labels for unlabeled folders.
Uses movie data pre-generated by OMDB.
Does soft-matching of folder names to titles in the db.
See https://chatgpt.com/share/6828d6bb-ca20-8001-8870-749624e17929
"""
import os
import re
import json
import argparse
import difflib
import openai
import readline
from typing import List, Dict, Optional
from dotenv import load_dotenv
from openai import OpenAI
from pydantic_settings import BaseSettings

IMDB_TAG_RE = re.compile(r'\s*\{imdb-[^\}]+\}$', re.IGNORECASE)
MINE_NEEDS_IMDB = '/Users/ericmelz/Data/code/synutil/source/movie_finder/data/mine_needs_imdb.jsonl'
MOVIES_FOLDER = '/Volumes/video-1/movies'


class Settings(BaseSettings):
    openai_api_key: str = ""
    omdb_api_key: str = ""

    class Config:
        env_file = ".env"


def load_movies(jsonl_path: str) -> List[Dict]:
    movies = []
    with open(jsonl_path, encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                movies.append(json.loads(line))
            except json.decoder.JSONDecodeError:
                print(f"Warning: skipping invalid JSON: {line}")
    return movies


def find_best_match(name: str, movies: List[Dict], cutoff=0.6) -> Optional[Dict]:
    """
    Try exact case-insensitive match on Title, then fuzzy match via difflib.
    """
    lname = name.lower()
    # exact
    for m in movies:
        if m.get("Title", "").lower() == lname:
            return m
    # fuzzy: get top close matches
    titles = [m["Title"] for m in movies]
    matches = difflib.get_close_matches(lname, titles, n=1, cutoff=cutoff)
    if matches:
        title = matches[0]
        for m in movies:
            if m["Title"] == title:
                return m
    return None


def llm_match(name: str, movies: List[Dict]) -> Optional[Dict]:
    """
    Use GPT to pick the correct Title and IMDB ID.
    """
    key = Settings().openai_api_key
    if not key:
        return None

    # build a short prompt with the top few candidates
    titles = [m["Title"] for m in movies]
    # pick 10 closest strings
    candidates = difflib.get_close_matches(name, titles, n=10, cutoff=0.0)
    prompt = (
        f"I have a movie folder named \"{name}\".  Here are some possible titles:\n\n"
        + "\n".join(f"- {t} (IMDB ID: {next(m['imdbID'] for m in movies if m['Title']==t)})"
                    for t in candidates[:10])
    )
    # print(prompt)
    client = OpenAI(api_key=key)
    resp = client.responses.create(
        model="gpt-4o",
        instructions="You are a helpful assistant capable of choosing movie titles",
        input=prompt,
        temperature=0,
    )
    text = resp.output_text
    # print(f'{text=}')
    # extract tt\d+
    m = re.search(r'(tt\d+)', text)
    if not m:
        return None
    imdb_id = m.group(1)
    # find movie dict
    for m in movies:
        if m.get("imdbID", "") == imdb_id:
            return m
    return None


def suggest_new_name(folder: str, movie: Dict) -> str:
    return f"{folder} {{imdb-{movie['imdbID']}}}"


def prompt_accept(default_name: str) -> Optional[str]:
    while True:
        resp = input(f"Rename to \"{default_name}\"? [y/n/q] ").strip().lower()
        if resp == 'y':
            return default_name
        elif resp == 'n':
            new_name = input("Enter new folder name or leave blank to skip): ").strip()
            return new_name or None
        elif resp == 'q':
            print("Quitting.")
            exit(0)
        else:
            print("Please enter 'y' to accept, 'n' to enter a custom name, or 'q' to quit.")


def main():
    movies = load_movies(MINE_NEEDS_IMDB)
    for entry in sorted(os.listdir(MOVIES_FOLDER)):
        full_path = os.path.join(MOVIES_FOLDER, entry)
        if not os.path.isdir(full_path):
            continue
        if IMDB_TAG_RE.search(full_path):
            continue  # already tagged

        movie = find_best_match(entry, movies)
        if not movie:
            movie = llm_match(entry, movies)

        if not movie:
            print(f"No match for '{entry}'.  Skipping.")
            continue

        suggestion = suggest_new_name(entry, movie)
        chosen = prompt_accept(suggestion)
        if not chosen:
            print(f"Skipping '{entry}'.")
            continue

        new_path = os.path.join(MOVIES_FOLDER, chosen)
        if os.path.exists(new_path):
            print(f"Cannot rename: target {new_path!r} already exists.")
        # os.rename(full_path, new_path)
        print(f"Successfully renamed {entry!r} â†’ '{chosen!r}'.")


if __name__ == '__main__':
    main()
